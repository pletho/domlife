export const DL_STATE=Object.freeze({EVENT_REQUESTED:'event:requested',BROWSER_RECOGNIZED:'browser:recognized',SERVER_SENT:'server:sent',SERVER_PROCESSING:'server:processing',SERVER_STREAMING:'server:streaming',SERVER_RESPONDED:'server:responded',BROWSER_RECEIVING:'browser:receiving',DOM_RENDERING:'dom:rendering',CLIENT_PROCESSING:'client:processing',CLIENT_DONE:'client:done',LOADING_END:'loading:end',RETRY_WAITING:'retry:waiting'});export class Emitter{constructor(){this.map=new Map()}on(t,f){this.map.has(t)||this.map.set(t,new Set);this.map.get(t).add(f);return()=>this.map.get(t).delete(f)}off(t,f){this.map.get(t)?.delete(f)}emit(t,p){this.map.get(t)?.forEach(f=>{try{f(p)}catch(e){}})}}export class StateMachine{constructor(b,i=DL_STATE.LOADING_END){this.bus=b;this.current=i;this.hooks=new Map}on(s,f){this.hooks.has(s)||this.hooks.set(s,new Set);this.hooks.get(s).add(f);return()=>this.hooks.get(s).delete(f)}async to(n,p={}){const r=this.current;if(r===n)return;try{window?.dispatchEvent?.(new CustomEvent('dl:state:exit',{detail:{prev:r,next:n,payload:p}}))}catch{}this.bus.emit('state:exit',{prev:r,next:n,payload:p});this.current=n;try{window?.dispatchEvent?.(new CustomEvent('dl:state:enter',{detail:{prev:r,next:n,payload:p}}));window?.dispatchEvent?.(new CustomEvent(`dl:state:${n}`,{detail:{prev:r,next:n,payload:p}}))}catch{}this.bus.emit('state:enter',{prev:r,next:n,payload:p});this.bus.emit('state:change',{prev:r,next:n,payload:p});const set=this.hooks.get(n);if(set){for(const f of set){try{await f({prev:r,next:n,payload:p})}catch(e){}}}}}